<!-- Published by Fog Creek Software CityDesk CQSXKDXJHSYDVISL/5193B323/49 -->


<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Using the /optimize switch in CSC</title>
  <link rel="stylesheet" href="../iunknown.css"/>
  <script type="text/javascript" src="http://www.haloscan.com/load.php?user=jlam"></script>
  <script language="javascript">
    function HaloScan2( id ) {
      location.href='http://www.haloscan.com/comments.php?user=jlam&comment='+id;
    }
  </script>
</head>
<body>
  <a href="http://www.iunknown.com"><img src="../Images/iunknown.png" width="350" height="60" border="0"></a> 
  <table width="700px" border="0" cellspacing="10">
    <tr>
      <td width="76%" valign="top">
        <div class="entryTitle">Using the /optimize switch in CSC</div>
        <div class="entryDate">2002-01-03</div>
        <p><P>While doing my day job, I was stepping through some JIT-compiled x86 code using the VS.NET debugger. It got me interested in the differences in generated code between code that was compiled without and with optimizations. So I decided to write this entry to record what I saw.</P>
<P>Here's the simplest possible method that I could think of:</P>
<P><CODE>static int Add( int x, int y ) <BR>{<BR>&nbsp; return x + y;<BR>}</CODE></P>
<P>The first thing to examine are the differences between the CIL that is generated by the CSC compiler. When you compile the code without using the /optimize switch, this is the CIL that was generated:</P>
<P><CODE>.method private hidebysig static int32&nbsp; SafeAdd(int32 x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32 y) cil managed<BR>{<BR>&nbsp; // Code size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 (0x8)<BR>&nbsp; .maxstack&nbsp; 2<BR>&nbsp; .locals ([0] int32 CS$00000003$00000000)<BR>&nbsp; IL_0000:&nbsp; ldarg.0<BR>&nbsp; IL_0001:&nbsp; ldarg.1<BR>&nbsp; IL_0002:&nbsp; add<BR>&nbsp; IL_0003:&nbsp; stloc.0<BR>&nbsp; IL_0004:&nbsp; br.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IL_0006<BR>&nbsp; IL_0006:&nbsp; ldloc.0<BR>&nbsp; IL_0007:&nbsp; ret<BR>} // end of method Class1::SafeAdd</CODE></P>
<P>When you compile this code using the /optimize switch, this is the CIL that I got:</P>
<P><CODE>.method private hidebysig static int32&nbsp; SafeAdd(int32 x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32 y) cil managed<BR>{<BR>&nbsp; // Code size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 (0x4)<BR>&nbsp; .maxstack&nbsp; 8<BR>&nbsp; IL_0000:&nbsp; ldarg.0<BR>&nbsp; IL_0001:&nbsp; ldarg.1<BR>&nbsp; IL_0002:&nbsp; add<BR>&nbsp; IL_0003:&nbsp; ret<BR>} // end of method Class1::SafeAdd</CODE></P>
<P>It's interesting that the "debug" build created an extra local variable to hold the intermediate results of the calculation. This is presumably done so that a debugger can let you step over the addition and see the result of that calculation. There is also the redundant br.s instruction that does nothing more than do an unconditional branch to the next line of code. Apparently this is done so that you can set a breakpoint on either the return x + y; line or the terminating curly brace.</P>
<P>When I examined the "debug" build using the VS.NET debugger in disassembly mode, this is the x86 instruction stream that I saw:</P>
<P><CODE>00000000 push ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; setup stack frame<BR>00000001 mov ebp,esp <BR>00000003 sub esp,0Ch&nbsp; <BR>00000006 push edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save edi<BR>00000007 push esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save esi<BR>00000008 push ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save ebx<BR>00000009 mov ebx,ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; x is in ecx<BR>0000000b mov esi,edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; y is in edx<BR>0000000d xor edi,edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; zero edi<BR>0000000f lea eax,[ebx+esi]&nbsp; ; add x and y, result in eax<BR>00000012 mov edi,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; store result in edi<BR>00000014 jmp 00000016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>00000016 mov eax,edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; move result to eax<BR>00000018 pop ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore ebx<BR>00000019 pop esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; restore esi<BR>0000001a pop edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore edi<BR>0000001b mov esp,ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; cleanup stack frame<BR>0000001d pop ebp <BR>0000001e ret </CODE></P>
<P>There are a number of interesting observations that we can make about this code. First, we can clearly see the fastcall calling convention in use: the ecx and edx registers hold the x and y parameters respectively. We can see that the return value of the method is returned in the eax register. We also see that space is being reserved on the stack for two parameters + a temporary variable even though x86 registers are used for all three values!</P>
<P>It's interesting to note that the edi register is being used as a temporary variable in this case.</P>
<P>When I examined the optimized build using the VS.NET debugger in disassembly mode, this is the x86 instruction stream that I saw:</P>
<P><CODE>00000000 push ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; setup stack frame<BR>00000001 mov ebp,esp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>00000003 sub esp,8 <BR>00000006 push edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save edi <BR>00000007 push esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save esi<BR>00000008 mov edi,ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; x is in ecx<BR>0000000a mov esi,edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; y is in edx<BR>0000000c lea eax,[edi+esi]&nbsp; ; add x and y, result in eax<BR>0000000f pop esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; restore esi<BR>00000010 pop edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore edi<BR>00000011 mov esp,ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; clean up stack frame<BR>00000013 pop ebp <BR>00000014 ret </CODE></P>
<P>In this case, we can see that no code was generated for the temporary variable, and the redundant jmp instruction has been eliminated. We also see that space is being reserved on the stack only for two parameters as the temporary variable is no longer used. There is no need to save the ebx register in this case since the edi register is no longer being used as a temporary variable.</P>
<P>I'm actually somewhat surprised that the sub esp, x instruction is even generated when it is pretty clear that the stack frame is never used due to the enregistration of the parameters and the variables. This looks like a healthy candidate for future optimization of small functions that never use the stack frame.</P><img src="../Images/blue_button.jpg" alt="Permanent Link" width="18" height="18" align="top"></p>
        <a href="javascript:HaloScan2('Weblog/fog0000000049.html');"><script type="text/javascript">postCount('Weblog/fog0000000049.html');</script></a>
      </td>
      <td width="24%" valign="top">
        <a href="http://www.iunknown.com/rss.xml"><img src="../Images/xml.png" width="36" height="14" border="0"></a>
  
        <p><img src="../Images/about.png" width="100" height="25"></p>
        <div class="aboutEntry"> 
          
            <A href="../About/Aboutme.html">About me</A><br>
          
            <A href="../About/fog0000000006.html">About this site</A><br>
          
            <A href="../About/fog0000000010.html">My plan</A><br>
          
            <A href="../About/fog0000000009.html">My other life</A><br>
          
            <A href="../About/fog0000000008.html">My products</A><br>
          
            <A href="../About/fog0000000013.html">My publications</A><br>
          
        </div>

        <p><img src="../Images/archives.png" width="100" height="25"></p>
        <div class="archiveEntry">
         
           <A href="../Archives/April2003.html">April 2003</A><br>
         
           <A href="../Archives/March2003.html">March 2003</A><br>
         
           <A href="../Archives/February2003.html">February 2003</A><br>
         
           <A href="../Archives/January2003.html">January 2003</A><br>
         
           <A href="../Archives/December2002.html">December 2002</A><br>
         
           <A href="../Archives/November2002.html">November 2002</A><br>
         
           <A href="../Archives/October2002.html">October 2002</A><br>
         
           <A href="../Archives/September2002.html">September 2002</A><br>
         
           <A href="../Archives/August2002.html">August 2002</A><br>
         
           <A href="../Archives/July2002.html">July 2002</A><br>
         
           <A href="../Archives/June2002.html">June 2002</A><br>
         
           <A href="../Archives/May2002.html">May 2002</A><br>
         
           <A href="../Archives/April2002.html">April 2002</A><br>
         
           <A href="../Archives/fog0000000116.html">March 2002</A><br>
         
           <A href="../Archives/fog0000000091.html">February 2002</A><br>
         
           <A href="../Archives/fog0000000046.html">January 2002</A><br>
         
           <A href="../Archives/fog0000000030.html">December 2001</A><br>
         
        </div>

        <p><img src="../Images/articles.png" width="100" height="25"></p>
        <div class="articleEntry">
          
            - <A href="../Articles/Booksuggestions.html">Book suggestions</A><br>
          
            - <A href="../Articles/fog0000000082.html">Interface dispatch vs. object reference dispatch</A><br>
          
            - <A href="../Articles/fog0000000065.html">x86 Resources</A><br>
          
            - <A href="../Articles/fog0000000041.html">Entertainment PC's Part 2</A><br>
          
            - <A href="../Articles/fog0000000034.html">Entertainment PC's</A><br>
          
            - <A href="../Articles/fog0000000025.html">Hello CppUnit</A><br>
          
        </div>

        <p><img src="../Images/links.png" width="100" height="25"></p>
        <div class="linkEntry">
          <a href="http://www.gotdotnet.com/team/dbox/spoutlet.aspx">Don Box</a><br>
          <a href="http://www.stronglytyped.com/">Richard Caetano</a><br>
          <a href="http://www.razorsoft.net/weblog/">Peter Drayton</a><br>
          <a href="http://radio.weblogs.com/0109845/">Jeroen Frijters</a><br>
          <a href="http://radio.weblogs.com/0105852/">Sam Gentile</a><br>
          <a href="http://radio.weblogs.com/0106747/">Scott Hanselman</a><br>
          <a href="http://radio.weblogs.com/0104813/">Drew Marsh</a><br>
          <a href="http://www.dotnetremoting.cc/dotnetcentric/">Ingo Rammer</a><br>
          <a href="http://www.winterdom.com/weblog/">Tomas Restrepo</a><br>
          <a href="http://www.sellsbrothers.com/">Chris Sells</a><br>
          <a href="http://www.joelonsoftware.com/">Joel Spolsky</a><br>
          <a href="http://radio.weblogs.com/0108971/">Clemens Vasters</a><br>
          <a href="http://staff.develop.com/jasonw/weblog/">Jason Whittington</a><br>
          <a href="http://dotnetguy.techieswithcats.com/">Brad Wilson</a><br>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
