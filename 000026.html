<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

<title>iunknown.com: Using the /optimize switch in CSC</title>

<link rel="stylesheet" href="http://www.iunknown.com/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.iunknown.com/index.rdf" />

<link rel="start" href="http://www.iunknown.com/" title="Home" />
<link rel="prev" href="http://www.iunknown.com/000025.html" title="More Entertainment PC Stuff" />

<link rel="next" href="http://www.iunknown.com/000027.html" title="Parameter arrays" />


<script type="text/javascript" language="javascript">
<!--

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

var HOST = 'www.iunknown.com';

// Copyright (c) 1996-1997 Athenia Associates.
// http://www.webreference.com/js/
// License is granted if and only if this entire
// copyright notice is included. By Tomer Shiran.

function setCookie (name, value, expires, path, domain, secure) {
    var curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + ((secure) ? "; secure" : "");
    document.cookie = curCookie;
}

function getCookie (name) {
    var prefix = name + '=';
    var c = document.cookie;
    var nullstring = '';
    var cookieStartIndex = c.indexOf(prefix);
    if (cookieStartIndex == -1)
        return nullstring;
    var cookieEndIndex = c.indexOf(";", cookieStartIndex + prefix.length);
    if (cookieEndIndex == -1)
        cookieEndIndex = c.length;
    return unescape(c.substring(cookieStartIndex + prefix.length, cookieEndIndex));
}

function deleteCookie (name, path, domain) {
    if (getCookie(name))
        document.cookie = name + "=" + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}

function fixDate (date) {
    var base = new Date(0);
    var skew = base.getTime();
    if (skew > 0)
        date.setTime(date.getTime() - skew);
}

function rememberMe (f) {
    var now = new Date();
    fixDate(now);
    now.setTime(now.getTime() + 365 * 24 * 60 * 60 * 1000);
    setCookie('mtcmtauth', f.author.value, now, '', HOST, '');
    setCookie('mtcmtmail', f.email.value, now, '', HOST, '');
    setCookie('mtcmthome', f.url.value, now, '', HOST, '');
}

function forgetMe (f) {
    deleteCookie('mtcmtmail', '', HOST);
    deleteCookie('mtcmthome', '', HOST);
    deleteCookie('mtcmtauth', '', HOST);
    f.email.value = '';
    f.author.value = '';
    f.url.value = '';
}

//-->
</script>





</head>

<body>

<div id="banner">
<h1><a href="http://www.iunknown.com/" accesskey="1"><img src="/mt-static/images/iunknown.png" width="350" height="60" border="0"></a></h1>
<span class="description">Home of the Practical Eye for the .NET Guy</span>
</div>

<div id="container">

<div class="blog">

<div id="menu">
<a href="http://www.iunknown.com/000025.html">&laquo; More Entertainment PC Stuff</a> |

<a href="http://www.iunknown.com/">Main</a>
| <a href="http://www.iunknown.com/000027.html">Parameter arrays &raquo;</a>

</div>

</div>


<div class="blog">

<h2 class="date">January 03, 2002</h2>

<div class="blogbody">

<h3 class="title">Using the /optimize switch in CSC</h3>

<p><P>While doing my day job, I was stepping through some JIT-compiled x86 code using the VS.NET debugger. It got me interested in the differences in generated code between code that was compiled without and with optimizations. So I decided to write this entry to record what I saw.</P><br />
<P>Here's the simplest possible method that I could think of:</P><br />
<P><CODE>static int Add( int x, int y ) <BR>{<BR>&nbsp; return x + y;<BR>}</CODE></P><br />
<P>The first thing to examine are the differences between the CIL that is generated by the CSC compiler. When you compile the code without using the /optimize switch, this is the CIL that was generated:</P><br />
<P><CODE>.method private hidebysig static int32&nbsp; SafeAdd(int32 x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32 y) cil managed<BR>{<BR>&nbsp; // Code size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8 (0x8)<BR>&nbsp; .maxstack&nbsp; 2<BR>&nbsp; .locals ([0] int32 CS$00000003$00000000)<BR>&nbsp; IL_0000:&nbsp; ldarg.0<BR>&nbsp; IL_0001:&nbsp; ldarg.1<BR>&nbsp; IL_0002:&nbsp; add<BR>&nbsp; IL_0003:&nbsp; stloc.0<BR>&nbsp; IL_0004:&nbsp; br.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IL_0006<BR>&nbsp; IL_0006:&nbsp; ldloc.0<BR>&nbsp; IL_0007:&nbsp; ret<BR>} // end of method Class1::SafeAdd</CODE></P><br />
<P>When you compile this code using the /optimize switch, this is the CIL that I got:</P><br />
<P><CODE>.method private hidebysig static int32&nbsp; SafeAdd(int32 x,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int32 y) cil managed<BR>{<BR>&nbsp; // Code size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 (0x4)<BR>&nbsp; .maxstack&nbsp; 8<BR>&nbsp; IL_0000:&nbsp; ldarg.0<BR>&nbsp; IL_0001:&nbsp; ldarg.1<BR>&nbsp; IL_0002:&nbsp; add<BR>&nbsp; IL_0003:&nbsp; ret<BR>} // end of method Class1::SafeAdd</CODE></P><br />
<P>It's interesting that the "debug" build created an extra local variable to hold the intermediate results of the calculation. This is presumably done so that a debugger can let you step over the addition and see the result of that calculation. There is also the redundant br.s instruction that does nothing more than do an unconditional branch to the next line of code. Apparently this is done so that you can set a breakpoint on either the return x + y; line or the terminating curly brace.</P><br />
<P>When I examined the "debug" build using the VS.NET debugger in disassembly mode, this is the x86 instruction stream that I saw:</P><br />
<P><CODE>00000000 push ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; setup stack frame<BR>00000001 mov ebp,esp <BR>00000003 sub esp,0Ch&nbsp; <BR>00000006 push edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save edi<BR>00000007 push esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save esi<BR>00000008 push ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save ebx<BR>00000009 mov ebx,ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; x is in ecx<BR>0000000b mov esi,edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; y is in edx<BR>0000000d xor edi,edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; zero edi<BR>0000000f lea eax,[ebx+esi]&nbsp; ; add x and y, result in eax<BR>00000012 mov edi,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; store result in edi<BR>00000014 jmp 00000016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>00000016 mov eax,edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; move result to eax<BR>00000018 pop ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore ebx<BR>00000019 pop esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; restore esi<BR>0000001a pop edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore edi<BR>0000001b mov esp,ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; cleanup stack frame<BR>0000001d pop ebp <BR>0000001e ret </CODE></P><br />
<P>There are a number of interesting observations that we can make about this code. First, we can clearly see the fastcall calling convention in use: the ecx and edx registers hold the x and y parameters respectively. We can see that the return value of the method is returned in the eax register. We also see that space is being reserved on the stack for two parameters + a temporary variable even though x86 registers are used for all three values!</P><br />
<P>It's interesting to note that the edi register is being used as a temporary variable in this case.</P><br />
<P>When I examined the optimized build using the VS.NET debugger in disassembly mode, this is the x86 instruction stream that I saw:</P><br />
<P><CODE>00000000 push ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; setup stack frame<BR>00000001 mov ebp,esp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>00000003 sub esp,8 <BR>00000006 push edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save edi <BR>00000007 push esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; save esi<BR>00000008 mov edi,ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; x is in ecx<BR>0000000a mov esi,edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; y is in edx<BR>0000000c lea eax,[edi+esi]&nbsp; ; add x and y, result in eax<BR>0000000f pop esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; restore esi<BR>00000010 pop edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; restore edi<BR>00000011 mov esp,ebp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; clean up stack frame<BR>00000013 pop ebp <BR>00000014 ret </CODE></P><br />
<P>In this case, we can see that no code was generated for the temporary variable, and the redundant jmp instruction has been eliminated. We also see that space is being reserved on the stack only for two parameters as the temporary variable is no longer used. There is no need to save the ebx register in this case since the edi register is no longer being used as a temporary variable.</P><br />
<P>I'm actually somewhat surprised that the sub esp, x instruction is even generated when it is pretty clear that the stack frame is never used due to the enregistration of the parameters and the variables. This looks like a healthy candidate for future optimization of small functions that never use the stack frame.</P></p>

<a name="more"></a>


<span class="posted">Posted by John at January  3, 2002 01:11 PM

<br /></span>

</div>

<div class="comments-head"><a name="mailthisentry"></a>Mail this entry</div>

<form method="post" action="http://www.iunknown.com/cgi-bin/mt-send-entry.cgi">
<input type="hidden" name="entry_id" value="26" />
<input type="hidden" name="_redirect" value="http://www.iunknown.com/000026.html" />
Email this entry to:<br />
<input name="to" size="20" /><br /><br />
Your email address:<br />
<input name="from" size="20" /><br /><br />
Message (optional):<br />
<textarea name="message" rows="5" cols="20" wrap="virtual"></textarea><br /><br />
<input type="submit" value="Send" />
</form>


<div class="comments-head"><a name="comments"></a>Comments</div>





</div>
</div>
</body>
</html>
