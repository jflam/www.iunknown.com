
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
<HTML>
  <HEAD>
    <title>Recommended book: Advanced Compiler Design and Implementation
    </title>
    <meta content="JavaScript" name="vs_defaultClientScript">
    <meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
    <LINK href="global.css" type="text/css" rel="stylesheet">
  </HEAD>
  <body MS_POSITIONING="GridLayout">
    <a href="Default.aspx">
      <img id="Image2" class="Logo" src="images/logo.png" alt="iunknown.com: building better software, faster" border="0" /></a>
    <form name="Form1" method="post" action="BookReview.aspx?asin=1558603204" id="Form1">
<input type="hidden" name="__VIEWSTATE" value="dDwxNzczMTIwMDYzO3Q8O2w8aTwxPjs+O2w8dDw7bDxpPDE+O2k8Mz47aTw1PjtpPDc+O2k8OT47aTwxMT47aTwxMz47aTwxND47aTwxNz47PjtsPHQ8cDxwPGw8SW1hZ2VVcmw7PjtsPGh0dHA6Ly9pbWFnZXMuYW1hem9uLmNvbS9pbWFnZXMvUC8xNTU4NjAzMjA0LjAxLl9TQ01aWlpaWlpaXy5qcGc7Pj47Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPEFkdmFuY2VkIENvbXBpbGVyIERlc2lnbiBhbmQgSW1wbGVtZW50YXRpb247Pj47Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPFN0ZXZlbiBNdWNobmljazs+Pjs+Ozs+O3Q8cDxwPGw8VGV4dDs+O2w8JDk0Ljk1Oz4+Oz47Oz47dDxwPHA8bDxUZXh0Oz47bDwkOTQuOTU7Pj47Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPDQuNTs+Pjs+Ozs+O3Q8cDxwPGw8VGV4dDs+O2w8MTM7Pj47Pjs7Pjt0PEA8aHR0cDovL3d3dy5hbWF6b24uY29tL2V4ZWMvb2JpZG9zL0FTSU4vMTU1ODYwMzIwNC9yZWY9bm9zaW0vaXVua25vd25jb20tMjA7Pjs7Pjt0PDtsPGk8MD47aTwxPjs+O2w8dDxAPEFtYXpvbi5jb207Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPE9wdGltaXppbmcgY29tcGlsZXJzLCB3aGljaCB0dXJuIGh1bWFuLXJlYWRhYmxlIHByb2dyYW1taW5nIGxhbmd1YWdlcyBpbnRvIHRoZSBzbWFsbGVzdCwgbW9zdCBlZmZpY2llbnQgbWFjaGluZSBjb2RlIHBvc3NpYmxlLCBhcmUgYW1vbmcgdGhlIG1vc3QgY29tcGxleCBwaWVjZXMgb2Ygc29mdHdhcmUgZXZlciB3cml0dGVuLiBCdWlsZGluZyBhIGNvbXBpbGVyIGlzIGJvdGggc2NpZW5jZSBhbmQgYmxhY2sgYXJ0IGFuZCBkZW1hbmRzIGFuIGludGltYXRlIGtub3dsZWRnZSBvZiBkYXRhIHN0cnVjdHVyZXMsIGFsZ29yaXRobXMsIGhpZ2gtbGV2ZWwgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLCBhbmQgcHJvY2Vzc29yIGFyY2hpdGVjdHVyZXMgYW5kIHRoZWlyIGluc3RydWN0aW9uIHNldHMuIFw8SVw+QWR2YW5jZWQgQ29tcGlsZXIgRGVzaWduIGFuZCBJbXBsZW1lbnRhdGlvblw8L0lcPiBwcmVzZW50cyBhIGNvbXByZWhlbnNpdmUgYW5kIHRlY2huaWNhbGx5IHVwLXRvLWRhdGUgbG9vayBhdCBkZXNpZ24gb2YgcmVhbC13b3JsZCBjb21waWxlcnMgZm9yIENJU0MtIGFuZCBSSVNDLWJhc2VkIHVuaS1wcm9jZXNzb3IgYXJjaGl0ZWN0dXJlcy4gVGhlIGF1dGhvciBsZWQgdGhlIGFkdmFuY2VkIGNvbXBpbGVyIGRlc2lnbiBhbmQgaW1wbGVtZW50YXRpb24gdGVhbXMgZm9yIGJvdGggSGV3bGV0dC1QYWNrYXJkJ3MgUEEtUklTQyBhbmQgU3VuIE1pY3Jvc3lzdGVtcydzIFNQQVJDIHByb2Nlc3NvcnMuOz4+Oz47Oz47Pj47Pj47Pj47Pqz0zWVHjCdt/dfdwhq1eYJJTFno" />

      <div class="BookReview"><img id="BookImage" class="BookReviewImage" src="http://images.amazon.com/images/P/1558603204.01._SCMZZZZZZZ_.jpg" alt="" border="0" />
        <span id="BookReviewTitle" class="BookReviewTitle">Advanced Compiler Design and Implementation</span>
        <div class="ItemDetail">By
          <span id="Authors">Steven Muchnick</span></div>
        <div class="ItemDetail">
          <span class="ItemCaption">List price:</span>
          <span id="ListPrice" class="ListPrice">$94.95</span>
          <span class="ItemCaption">Our price:</span>
          <span id="OurPrice" class="OurPrice">$94.95</span>
        </div>
        <div class="ItemDetail">
          <span class="ItemCaption">Average customer review:</span>
          <span id="AverageReview">4.5</span>
          based on
          <span id="TotalReviews">13</span>
          reviews.
        </div>
        <div class="BuyButton">
          <a href='http://www.amazon.com/exec/obidos/ASIN/1558603204/ref=nosim/iunknowncom-20'>
            <img id="Image1" src="Images/buy_from_amazon.gif" alt="" border="0" /></a>
        </div>
        <table class="ReviewBody">
          <tr>
            <td class="ReviewColumn">
              <table id="EditorialReviewsPanel" class="ReviewSection" cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td>
	
                <DIV class="ReviewHeading">Amazon.com:</DIV>
                <span id="Label1">Optimizing compilers, which turn human-readable programming languages into the smallest, most efficient machine code possible, are among the most complex pieces of software ever written. Building a compiler is both science and black art and demands an intimate knowledge of data structures, algorithms, high-level programming languages, and processor architectures and their instruction sets. <I>Advanced Compiler Design and Implementation</I> presents a comprehensive and technically up-to-date look at design of real-world compilers for CISC- and RISC-based uni-processor architectures. The author led the advanced compiler design and implementation teams for both Hewlett-Packard's PA-RISC and Sun Microsystems's SPARC processors.</span>
              
</td></tr></table>
              <table id="CustomerReviewsPanel" class="ReviewSection" cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td>
	
                <DIV class="ReviewHeading">Customer reviews:</DIV>
                
                    <div class="CustomerReviewSummary">Good for seasoned compiler writers, bad for CS students</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>1</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>5</span>
                      /
                      <span>8</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2004-12-14</span>
                    </div>
                    <span>Ok, let's be fair. This book provides a broad coverage of useful optimizations and it will be useful in case you work writing compilers AND have some experience.
<br />
<br />However, for learning the concepts, it is a very bad material. At the end you end up confused under a pile of thousands of lines of pseudocode in a weird notation (invented by the author) called "I CAN" (yes you can write a very bad book Mr. Muchnick) instead of reading useful explanations of the topics. The author also assumes that you already know some concepts and that's why he does not explain them as he should. If you want to really understand this book, first review Chapter 10 of the Dragon Book. I thought that the Dragon book was not so good because you have to re read some things in order to fully understand, but with Muchnick's book that is not always possible. 
<br />
<br />You can also take a look at Morgan's book (unfortunately, out of print) or just read the papers (as the first reviewer suggested). This book is not enough, and sadly, a lot of "teachers" think of it as a kind of "bible" and as a very bad excuse to teach very poorly. Some of them even don't master all the concepts presented there and have to use other books (their "dirty little secret") but they don't tell you which ones and continue praising this bad piece of work. If you are a CS student who really wants to learn, be warned that this book is not for you (it has at least three erratas and still has errors!)</span>
                  
                    <div class="CustomerReviewSummary">Excellent</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>13</span>
                      /
                      <span>15</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-10-13</span>
                    </div>
                    <span>Advances in compiler design do not get much press these days. The reasons for this are unclear, but no doubt the perception that compilers need no further improvement has something to do with this. This book, written by one of the leading experts on compilers, certainly dispels this belief. Once readers get used to the idiosyncratic ICAN (Informal Compiler Algorithm Notation) invented by the author and used throughout the book, they get a comprehensive overview of compilers, especially that of optimization. Compilers for the SPARC, PowerPC, DEC, and Pentium architectures are treated in the book. The predominant emphasis of the book is in optimization, and so a few more recent and important topics in compiler construction, such as partial evaluation, are not discussed. Readers are expected to have a prior background in elementary compiler theory. My primary interest in reading the book was to gain insight into the compilation issues that arise in symbolic programming languages such as LISP and Prolog. <p>	A detailed review of this book cannot be done for lack of space, but some of the helpful aspects and interesting discussions in the book include: 1. The "wrap-up" section at the end of each chapter, giving a compact summary of what was done in the chapter. 2. Generating loads and stores: The author shows how to move values to and from registers using routines more sophisticated than simply loading values into registers before using them or storing values as soon as they have been computed. 3. The main issues in the use of registers, such as variable allocation, efficiency of procedural calls, and scoping. The author lists the different categories that will result in contention for registers, such as stack, frame, and global offset table pointers and dynamic and static links. 4. The local stack frame and its uses, such as holding indexed variables (arrays, etc.) and debugging. 5. The five different parameter-passing mechanisms: call by value, call by result, call by value-result, call by reference, and call by name. A thorough discussion is given of their properties and what languages make use of them. In particular, the author notes that in the languages C and C++, call by value is the only parameter-passing mechanism, but that the address of an object may be passed, thus emulating essentially call by reference. This can be a source of confusion to those who program in C and C++. The most exotic of these mechanisms is call by name, which is a form of "lazy evaluation" in functional programming languages. The author gives a code example of the call by name parameter passing in ALGOL 60. I don't know of any modern practical programming languages that make use of call by name. 6. Shared libraries and the role of semantic linking and position independent code. 7. The compilation issues that arise in symbolic languages, such as LISP and Prolog. These languages typically have run-time type checking and function polymorphism, which gives them their power and ease of use. The author discusses how to produce efficient code for these languages. Since heap storage is utilized heavily by these languages, the allocation and recovering of it is very important. "Generation scavenging" is mentioned as the most efficient method for doing garbage collection in these languages. This method has been advertised in the literature as one that minimizes the time needed for storage reclamation in comparison with other approaches. In addition, the use of "on-the-fly" recompilation for polymorphic-language implementations is discussed. 8. Dynamic programming and its role in automatic production of code generators, as contrasted with the "greedy approach". The author explains the need for "uniform register machines" in the dynamic programming algorithm. 9. Interval analysis and its use in the analysis of control flow. This technique has been used in the field called "abstract interpretation" in recent years, the aim of which is too automatically and intelligently test program code. 10. Dependencies between dynamically allocated objects, such as links between graph structures in LISP and Prolog. The author describes the Hummel-Hendren-Nicolau technique for doing this, which involves naming schemes for locations in heap memory, a collection of axioms for characterizing aliasing locations among locations, and lastly, and most interestingly, utilizes a theorem prover to establish the properties of the data structures. The author emphasizes though that this technique, and others developed for doing dependence analysis of dynamically allocated objects, are very computationally intensive. 11. Individual optimizations, which the author divides into four groups in order of importance. 12. Induction-variable optimizations and their role in loop optimizations. The author shows how to identify induction variables, and how to transform them using various techniques, going by the name strength reduction, induction-variable removal, and linear-function test replacement. 13. Procedure integration and its role in "inlining" procedures in languages such as C++. The author emphasizes the drawbacks in using inlining, such as its impact on cache misses. 14. The trade-off between object abstraction and optimization, which occurs in object-oriented languages such as C++. The author discusses in detail the role of interprodecural optimizations in dealing with abstraction in the object-oriented modular approach to programming, particularly the identification of "side effects" in making procedure calls. 15. Code optimization that takes advantage of the memory hierarchy, such as data and instruction caches, and how to improve register allocation for arrays. The author gives a detailed and highly interesting discussion of scalar replacement for array elements. 16. Future trends and research in compiler design. The author mentions a few which he believes will dominate in the upcoming decade, such as scalar-oriented and data-cache optimizations. Scalar compilation will be he most active research area in his opinion. At the present time, there has been discussion of "intelligent compilers" that will interact with the user to develop optimal code, or even produce correct programs. These compilers will understand the intentions of the program and warn the user if these are violated, as well as reduce the time and cost needed for testing programs.</span>
                  
                    <div class="CustomerReviewSummary">Excellent coverage</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>2</span>
                      /
                      <span>5</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-08-15</span>
                    </div>
                    <span>I would suggest to the average reader to first <br>get "Programming Language Pragmatics" by michael l. scott<br>and coming to this book.<p>Reason being that "Programming Language Pragmatics" would<br>provide ground-coverage before moving on to this book.<p>happy reading!</span>
                  
                    <div class="CustomerReviewSummary">Great Back-end Book</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>3</span>
                      /
                      <span>5</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-08-03</span>
                    </div>
                    <span>The book does its job and does it well.  But, it's only fair to warn that the book concentrates on code generation, optimization, instruction scheduling, etc.  If you're looking for attribute grammars, etc., look somewhere else.  When you're done looking for that stuff, get this book.</span>
                  
                    <div class="CustomerReviewSummary">A great book on advanced compiler design</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>17</span>
                      /
                      <span>19</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-04-14</span>
                    </div>
                    <span>I have been working on language processors, interpreters and <br>compilers for almost twenty years.  I try to order all the books<br>that have something unique to say about compiler design and<br>implementation.  This is one of the best books I have seen on<br>advanced compiler design.  I have owned it since it was first<br>published.  Going back and rereading it I am reminded of what<br>and excellent book it is, which is what motivated this review.<p>Advanced compiler design deals with various forms of optimization,<br>including local, global and loop optimization.  This is a complex<br>topic with thirty years of research behind it (it is interesting<br>to note that the late Gary Kildall, of CP/M fame, did some early<br>work on optiimization in the early 1970s).  No single book can<br>provide complete coverage of all optimization issues.  However,<br>this book, along with Allen and Kennedy's equally excellent<br>"Optimizing Compilers for Modern Architectures" covers almost<br>everything you need to know.<p>One of the problems with the academic literature on compiler <br>optimization is that it can be unnecessarily obscure.  Muchnick<br>writes clearly, with the implementer in mind.  He provides a<br>wide range of techniques, allowing the implementer to choose<br>the correct one for a given compiler.  This approach is both<br>useful and necessary: there is no single method for building<br>a compiler, given the range of languages and design objectives.<p>Muchnick covers everything you need to know about local and<br>global scalar optimization, including scalar optimization in<br>loops and optimization for modern processor architecture.<br>The only thing missing is an indepth coverage of loop dependence<br>and optimization techniques, which is provided by Allen and<br>Kennedy.<p>If you are working on the design, implementation or extension of<br>a modern compiler, this book should be part of your library.</span>
                  
              
</td></tr></table>
            </td>
            <td class="ReviewSideBar">
              <div class="ItemCaption">Customers also bought:</div>
              
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=1558604960'>
                      Linkers and Loaders
                    </a>
                    <div class="SimilarItemRatings">Rating: 3.5 based on 13 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=1558602860'>
                      Optimizing Compilers for Modern Architectures: A Dependence-based Approach
                    </a>
                    <div class="SimilarItemRatings">Rating: 5.0 based on 2 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=052182060X'>
                      Modern Compiler Implementation in Java
                    </a>
                    <div class="SimilarItemRatings">Rating: 2.5 based on 20 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=0201100886'>
                      Compilers
                    </a>
                    <div class="SimilarItemRatings">Rating: 4.0 based on 47 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=1558604421'>
                      Programming Language Pragmatics
                    </a>
                    <div class="SimilarItemRatings">Rating: 5.0 based on 12 reviews</div>
                  </div>
                
              <div class="GoogleBookAd">
                <script type="text/javascript"><!--
                google_ad_client = "pub-8264790134546506";
                google_ad_width = 160;
                google_ad_height = 600;
                google_ad_format = "160x600_as";
                google_ad_channel ="4375045039";
                google_color_border = "CCCCCC";
                google_color_bg = "FFFFFF";
                google_color_link = "000000";
                google_color_url = "666666";
                google_color_text = "333333";
                //--></script>
                <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
                </script>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </form>
  </body>
</HTML>
