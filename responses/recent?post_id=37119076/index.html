{"post_id":37119076,"html":"\u003Cdiv class='p_response_container' style='display:none;'\u003E\n\u003Cheader class='clearfix'\u003E\n\u003Ca href=\"http://iunknown.com/2006/10/one-way-to-look-at-the-world.html\" class=\"p_view_all_link\"\u003EView All 5\u003C/a\u003E\n\u003Ch1\u003EMost Recent Responses\u003C/h1\u003E\n\u003C/header\u003E\n\u003Cdiv class='p_responses_list clearfix' data-posterous-responses-container\u003E\n\u003Carticle class='p_comment p_response' style='display:none;'\u003E\n\u003Cdiv class='p_info'\u003E\n\u003Cspan class='p_icon'\u003E\u003C/span\u003E\n\u003Ctime pubdate='1160315188'\u003Eover 6 years ago\u003C/time\u003E\nJohn Lam responded:\n\u003C/div\u003E\n\u003Cdiv class='p_comment_body'\u003E\n\u003Cdiv class='p_profile_photo'\u003E\n\u003Cimg alt=\"\" src=\"/images/profile/missing-user-35.png?1367517938\" /\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_text'\u003E\nBut a language like Ruby is a type-safe dynamic language (otherwise known as a strong-dynamic typed language). I think what you mean is that we get some measure of type-safety at compile time vs. run-time (perhaps via optional type annotations like what Python's considering doing?)\u003Cbr /\u003ENow if this is the case, do you want this for the compile time type checking ability, or for performance? If the latter, the folks in the Smalltalk world have already discovered that optional type annotations are actually ignored in their quest to get higher performance - see Avi Bryant's writeup of the Strongtalk VM here: \u003Ca href=\"http://smallthought.com/avi/?p=16.\" rel=\"nofollow\"\u003Ehttp://smallthought.com/avi/?p=16.\u003C/a\u003E\u003Cbr /\u003EIn the case of the former, if people program 'static style' then I think this will help catch the same class of bugs that we catch in C# today. However, if people program 'dynamic style' with liberal use of eval and method_missing, then many of the benefits of optional type annotations would be lost.\u003Cbr /\u003EOr is there some third scenario that you're looking for?\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cul class='p_action_links'\u003E\n\u003C/ul\u003E\n\n\u003C/article\u003E\n\n\u003Carticle class='p_comment p_response' style='display:none;'\u003E\n\u003Cdiv class='p_info'\u003E\n\u003Cspan class='p_icon'\u003E\u003C/span\u003E\n\u003Ctime pubdate='1160325498'\u003Eover 6 years ago\u003C/time\u003E\nRob responded:\n\u003C/div\u003E\n\u003Cdiv class='p_comment_body'\u003E\n\u003Cdiv class='p_profile_photo'\u003E\n\u003Cimg alt=\"\" src=\"/images/profile/missing-user-35.png?1367517938\" /\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_text'\u003E\nI think the key (as Tomas mentions) is the \"non-inferencing\" modifier he uses.  Staticly typed languages with powerful type inference are nearly as unlabeled as dynamic languages with the added bonus of at least some compile-time checking.\u003Cbr /\u003EI'm still very new to dynamic languages in general (if you don't count javascript web programming stuff), so I know I'm not making a fair comparison, it's just that when I think of strongly staticly typed I think of SML and how if my programs compiled, they basically worked, whereas when I think of dynamic I think of javascript and how I'd get goofy results because internally something was doing a string compare instead of a numeric one.\u003Cbr /\u003EBy the same token, I love the method_missing and metaprogramming stuff in Ruby, so I guess I'm damned either way.\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cul class='p_action_links'\u003E\n\u003C/ul\u003E\n\n\u003C/article\u003E\n\n\u003Carticle class='p_comment p_response' style='display:none;'\u003E\n\u003Cdiv class='p_info'\u003E\n\u003Cspan class='p_icon'\u003E\u003C/span\u003E\n\u003Ctime pubdate='1160499823'\u003Eover 6 years ago\u003C/time\u003E\nBertrand responded:\n\u003C/div\u003E\n\u003Cdiv class='p_comment_body'\u003E\n\u003Cdiv class='p_profile_photo'\u003E\n\u003Cimg alt=\"\" src=\"/images/profile/missing-user-35.png?1367517938\" /\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_text'\u003E\nI meant it for type checking. Perf is a strange beast and all the Joels of the world should be careful about definitive assertions about perf, perfectly agreed. I value the eval and missing method features, as well as the ability to build an object field by field and extend it as needed, these are to me the essence of dynamic languages.\u003Cbr /\u003EMy point is that those can be orthogonal to type safety. I really think that the benefits of type safety (which come from most methods being built to accept objects that have at least some expected behavior, which you can call a type, and anything else is an error) can be brought to dynamic languages without perverting them, and that the essence of dynamic languages can be brought to type-safe languages (which you can see a beginning for in C#3.0 for example).\u003Cbr /\u003EAnother point is that type safety, although ideally enforced during compile-time, can also be enforced at runtime if no compile time exists. We're doing that in Atlas for JavaScript, only in debug mode (so that in release you keep perf reasonable). It makes debugging a lot less painful and removes the pain of having to write the most repetitive unit tests: the only unit tests you need to write are the ones that ensure the semantics of your objects, not the ones that do the job of the compiler. And it's declared through annotations.\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cul class='p_action_links'\u003E\n\u003C/ul\u003E\n\n\u003C/article\u003E\n\n\u003C/div\u003E\n\u003Cdiv class='p_comment_form p_logged_in'\u003E\n\u003Ch1\u003ELeave a Comment\u003C/h1\u003E\n\u003Cform action=\"/responses/create\" class=\"new_comment clearfix\" id=\"new_comment\" method=\"post\"\u003E\u003Cdiv style=\"margin:0;padding:0;display:inline\"\u003E\u003Cinput name=\"authenticity_token\" type=\"hidden\" value=\"K5qluXl5HOIU9bWdq9oJYrEuVokj7nLG7aYeXTLdHqg=\" /\u003E\u003C/div\u003E\n\u003Cdiv class='p_not_authorized p_comment_section'\u003E\n\u003Cdiv class='p_additional_fields'\u003E\n\u003Clabel for=\"comment_name\"\u003EName:\u003C/label\u003E\n\u003Cinput id=\"comment_name\" maxlength=\"80\" name=\"comment[name]\" size=\"40\" type=\"text\" /\u003E\n\u003Clabel class=\"p_comment_email\" for=\"comment_comment_email\"\u003ELeave this field blank to comment.\u003C/label\u003E\n\u003Cinput class=\"p_comment_email\" id=\"comment_comment_email\" maxlength=\"80\" name=\"comment[comment_email]\" size=\"40\" type=\"text\" /\u003E\n\u003Clabel for=\"comment_toast\"\u003EEmail:\u003C/label\u003E\n\u003Cinput id=\"comment_toast\" maxlength=\"80\" name=\"comment[toast]\" size=\"40\" type=\"text\" /\u003E\n\u003Clabel for=\"comment_url\"\u003EHomepage:\u003C/label\u003E\n\u003Cinput id=\"comment_url\" maxlength=\"80\" name=\"comment[url]\" size=\"40\" type=\"text\" /\u003E\n\u003C/div\u003E\n\u003Caside class='p_login_options'\u003E\n\u003Cdiv class='p_asterisk'\u003E\u003C/div\u003E\n\u003Ch1\u003EWant to skip this stuff?\u003C/h1\u003E\n\u003Cp\u003ELogin with any of the following:\u003C/p\u003E\n\u003Cdiv class='p_login_buttons'\u003E\n\u003Ca href=\"http://posterous.com/login?flow=newcomment\u0026amp;jumpto=http%3A%2F%2Fiunknown.com%2F2006%2F10%2Fone-way-to-look-at-the-world.html%23comment\" class=\"p_posterous_login\"\u003ERegister or login to Posterous\u003C/a\u003E\n\u003Ca href=\"#\" class=\"p_twitter_login\" data-posterous-jumpto-url=\"http://iunknown.com/2006/10/one-way-to-look-at-the-world.html#comment\" data-posterous-post-id=\"37119076\" data-posterous-redirect-url=\"http://posterous.com/oauth/init_oauth_and_redirect/?ssod=iunknown.com\u0026amp;oauth_provider_type=\" data-posterous-twitter-login-button=\"true\"\u003E\u003Cimg alt=\"Sign in with Twitter\" src=\"/images/site/sign_in_with_twitter.png?1367517938\" /\u003E\u003C/a\u003E\n\u003C/div\u003E\n\n\u003C/aside\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_section'\u003E\n\u003Clabel for=\"comment_body\"\u003EComment:\u003C/label\u003E\n\u003Cdiv class='p_comment_area'\u003E\n\u003Ctextarea cols=\"40\" id=\"comment_body\" name=\"comment[body]\" onChange=\"if (this.scrollHeight \u0026gt; this.clientHeight \u0026amp;\u0026amp; !window.opera){this.rows += 1;}\" onKeyPress=\"if (this.scrollHeight \u0026gt; this.clientHeight \u0026amp;\u0026amp; !window.opera){this.rows += 1;}\" rows=\"5\"\u003E\u003C/textarea\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_section'\u003E\n\u003Cinput id=\"comment_post_id\" name=\"comment[post_id]\" type=\"hidden\" value=\"37119076\" /\u003E\n\u003Cdiv class='p_submit'\u003E\u003Cbutton button=\"true\" class=\" action_button\"\u003E\u003Cspan class=\"\"\u003EPost this Comment\u003C/span\u003E\u003C/button\u003E\u003C/div\u003E\n\u003C/div\u003E\n\u003C/form\u003E\n\u003C/div\u003E\n\n\u003C/div\u003E\n","responses":[{"name":"John Lam","body_html":"But a language like Ruby is a type-safe dynamic language (otherwise known as a strong-dynamic typed language). I think what you mean is that we get some measure of type-safety at compile time vs. run-time (perhaps via optional type annotations like what Python's considering doing?)\u003Cbr /\u003ENow if this is the case, do you want this for the compile time type checking ability, or for performance? If the latter, the folks in the Smalltalk world have already discovered that optional type annotations are actually ignored in their quest to get higher performance - see Avi Bryant's writeup of the Strongtalk VM here: \u003Ca href=\"http://smallthought.com/avi/?p=16.\" rel=\"nofollow\"\u003Ehttp://smallthought.com/avi/?p=16.\u003C/a\u003E\u003Cbr /\u003EIn the case of the former, if people program 'static style' then I think this will help catch the same class of bugs that we catch in C# today. However, if people program 'dynamic style' with liberal use of eval and method_missing, then many of the benefits of optional type annotations would be lost.\u003Cbr /\u003EOr is there some third scenario that you're looking for?","created_at":"2006/10/08 06:46:28 -0700","body":"But a language like Ruby is a type-safe dynamic language (otherwise known as a strong-dynamic typed language). I think what you mean is that we get some measure of type-safety at compile time vs. run-time (perhaps via optional type annotations like what Python's considering doing?)\nNow if this is the case, do you want this for the compile time type checking ability, or for performance? If the latter, the folks in the Smalltalk world have already discovered that optional type annotations are actually ignored in their quest to get higher performance - see Avi Bryant's writeup of the Strongtalk VM here: http://smallthought.com/avi/?p=16.\nIn the case of the former, if people program 'static style' then I think this will help catch the same class of bugs that we catch in C# today. However, if people program 'dynamic style' with liberal use of eval and method_missing, then many of the benefits of optional type annotations would be lost.\nOr is there some third scenario that you're looking for?\n","post_id":37119076,"id":6497623,"display_name":"John Lam","comment_type":"comment","display_url":null,"allowed":true,"display_photo":"/images/profile/missing-user-35.png"},{"name":"Rob","body_html":"I think the key (as Tomas mentions) is the \"non-inferencing\" modifier he uses.  Staticly typed languages with powerful type inference are nearly as unlabeled as dynamic languages with the added bonus of at least some compile-time checking.\u003Cbr /\u003EI'm still very new to dynamic languages in general (if you don't count javascript web programming stuff), so I know I'm not making a fair comparison, it's just that when I think of strongly staticly typed I think of SML and how if my programs compiled, they basically worked, whereas when I think of dynamic I think of javascript and how I'd get goofy results because internally something was doing a string compare instead of a numeric one.\u003Cbr /\u003EBy the same token, I love the method_missing and metaprogramming stuff in Ruby, so I guess I'm damned either way.","created_at":"2006/10/08 09:38:18 -0700","body":"I think the key (as Tomas mentions) is the \u0026quot;non-inferencing\u0026quot; modifier he uses.  Staticly typed languages with powerful type inference are nearly as unlabeled as dynamic languages with the added bonus of at least some compile-time checking.\nI'm still very new to dynamic languages in general (if you don't count javascript web programming stuff), so I know I'm not making a fair comparison, it's just that when I think of strongly staticly typed I think of SML and how if my programs compiled, they basically worked, whereas when I think of dynamic I think of javascript and how I'd get goofy results because internally something was doing a string compare instead of a numeric one.\nBy the same token, I love the method_missing and metaprogramming stuff in Ruby, so I guess I'm damned either way.\n","post_id":37119076,"id":6497624,"display_name":"Rob","comment_type":"comment","display_url":null,"allowed":true,"display_photo":"/images/profile/missing-user-35.png"},{"name":"Bertrand","body_html":"I meant it for type checking. Perf is a strange beast and all the Joels of the world should be careful about definitive assertions about perf, perfectly agreed. I value the eval and missing method features, as well as the ability to build an object field by field and extend it as needed, these are to me the essence of dynamic languages.\u003Cbr /\u003EMy point is that those can be orthogonal to type safety. I really think that the benefits of type safety (which come from most methods being built to accept objects that have at least some expected behavior, which you can call a type, and anything else is an error) can be brought to dynamic languages without perverting them, and that the essence of dynamic languages can be brought to type-safe languages (which you can see a beginning for in C#3.0 for example).\u003Cbr /\u003EAnother point is that type safety, although ideally enforced during compile-time, can also be enforced at runtime if no compile time exists. We're doing that in Atlas for JavaScript, only in debug mode (so that in release you keep perf reasonable). It makes debugging a lot less painful and removes the pain of having to write the most repetitive unit tests: the only unit tests you need to write are the ones that ensure the semantics of your objects, not the ones that do the job of the compiler. And it's declared through annotations.","created_at":"2006/10/10 10:03:43 -0700","body":"I meant it for type checking. Perf is a strange beast and all the Joels of the world should be careful about definitive assertions about perf, perfectly agreed. I value the eval and missing method features, as well as the ability to build an object field by field and extend it as needed, these are to me the essence of dynamic languages.\nMy point is that those can be orthogonal to type safety. I really think that the benefits of type safety (which come from most methods being built to accept objects that have at least some expected behavior, which you can call a type, and anything else is an error) can be brought to dynamic languages without perverting them, and that the essence of dynamic languages can be brought to type-safe languages (which you can see a beginning for in C#3.0 for example).\nAnother point is that type safety, although ideally enforced during compile-time, can also be enforced at runtime if no compile time exists. We're doing that in Atlas for JavaScript, only in debug mode (so that in release you keep perf reasonable). It makes debugging a lot less painful and removes the pain of having to write the most repetitive unit tests: the only unit tests you need to write are the ones that ensure the semantics of your objects, not the ones that do the job of the compiler. And it's declared through annotations.\n","post_id":37119076,"id":6497625,"display_name":"Bertrand","comment_type":"comment","display_url":null,"allowed":true,"display_photo":"/images/profile/missing-user-35.png"}]}