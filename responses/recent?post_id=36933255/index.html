{"post_id":36933255,"html":"\u003Cdiv class='p_response_container' style='display:none;'\u003E\n\u003Cheader class='clearfix'\u003E\n\u003Ca href=\"http://iunknown.com/2006/06/rubyclr-identity-woes.html\" class=\"p_view_all_link\"\u003EView All 4\u003C/a\u003E\n\u003Ch1\u003EMost Recent Responses\u003C/h1\u003E\n\u003C/header\u003E\n\u003Cdiv class='p_responses_list clearfix' data-posterous-responses-container\u003E\n\u003Carticle class='p_comment p_response' style='display:none;'\u003E\n\u003Cdiv class='p_info'\u003E\n\u003Cspan class='p_icon'\u003E\u003C/span\u003E\n\u003Ctime pubdate='1149297488'\u003Ealmost 7 years ago\u003C/time\u003E\nWilco Bauwer responded:\n\u003C/div\u003E\n\u003Cdiv class='p_comment_body'\u003E\n\u003Cdiv class='p_profile_photo'\u003E\n\u003Cimg alt=\"\" src=\"/images/profile/missing-user-35.png?1367517938\" /\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_text'\u003E\nRight now what I do in IronRuby to support interfaces is create proxy types on the fly (per interface type). Proxy types derive from a shared base class in which I partially deal with identity (or rather equality). It overloads the relevant operators and implements some relevant interfaces by basically forwarding calls to the underlying Ruby object it represents.\u003Cbr /\u003EThere are some obvious caveats however. Proxy types do not represent the true identity of the underlying Ruby object - it only tries to give you the illusion. When you would actually compare references though (which is what will happen in several scenarios), you will not always get the expected result. Imagine a Ruby object which implements IFoo and IBar and lets say we've got a .NET type with the following methods:\u003Cbr /\u003Evoid X(IFoo f);\u003Cbr /\u003Evoid Y(IBar b);\u003Cbr /\u003EWhen you would pass the Ruby object to X(IFoo f), a proxy type is generated (if it doesn't exist yet) and it is instantiated (if no instance was created yet). In subsequent calls the same proxy type instance will be passed, in which case identity is preserved.\u003Cbr /\u003EHowever, when you would pass the same Ruby object to Y(IBar b) an instance of a different proxy type is passed. Identity crisis is what follows when object references are compared instead of checking equality.\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cul class='p_action_links'\u003E\n\u003C/ul\u003E\n\n\u003C/article\u003E\n\n\u003Carticle class='p_comment p_response' style='display:none;'\u003E\n\u003Cdiv class='p_info'\u003E\n\u003Cspan class='p_icon'\u003E\u003C/span\u003E\n\u003Ctime pubdate='1149313369'\u003Ealmost 7 years ago\u003C/time\u003E\nNick Guerrera responded:\n\u003C/div\u003E\n\u003Cdiv class='p_comment_body'\u003E\n\u003Cdiv class='p_profile_photo'\u003E\n\u003Cimg alt=\"\" src=\"/images/profile/missing-user-35.png?1367517938\" /\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_text'\u003E\nIt's probably a good idea to use System.CompilerServices.RuntimeHelpers.GetHashCode. A non-virtual call to Object.GetHashCode is equivalent, but unverifiable.\u003Cbr /\u003EAs for the interface issue, what about getting rid of the .as operation entirely? It seems out of place to me in a world of duck typing.\u003Cbr /\u003ECan you make the original proxy object surface all interface methods as well? I'm sure this already works for implicit interface implementations. For explicit interface implementations, you could elevate them to normal methods in the absence of ambiguity.\u003Cbr /\u003EDealing with ambiguity in the face of explicit interface implementation is the tough part. One dodge would be to use name mangling for disambiguation, but that would break duck typing.\u003Cbr /\u003EI think a better approach would be to provide a method on the proxy object which allows the user to do the disambiguation. For example, given an object which implements both IEnumerable.GetEnumerator and IFoo.GetEnumerator, you could do the following:\u003Cbr /\u003Eobject.select_interface_method(\"GetEnumerator\", IEnumerable)\u003Cbr /\u003Ex = object.GetEnumerator()\u003Cbr /\u003E-- calls IEnumerable.GetEnumerator()\u003Cbr /\u003Eobject.select_interface_method(\"GetEnumerator\", IFoo)\u003Cbr /\u003Ex = object.GetEnumerator()\u003Cbr /\u003E-- calls IFoo.GetEnumerator()\u003Cbr /\u003EJust a thought.\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cul class='p_action_links'\u003E\n\u003C/ul\u003E\n\n\u003C/article\u003E\n\n\u003Carticle class='p_comment p_response' style='display:none;'\u003E\n\u003Cdiv class='p_info'\u003E\n\u003Cspan class='p_icon'\u003E\u003C/span\u003E\n\u003Ctime pubdate='1149376129'\u003Ealmost 7 years ago\u003C/time\u003E\nNick Guerrera responded:\n\u003C/div\u003E\n\u003Cdiv class='p_comment_body'\u003E\n\u003Cdiv class='p_profile_photo'\u003E\n\u003Cimg alt=\"\" src=\"/images/profile/missing-user-35.png?1367517938\" /\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_text'\u003E\nAlso, the value returned from GetHashCode (whether overridden or not) is not guaranteed to be unique to the object instance and therefore cannot be used as the key into a hashtable.\u003Cbr /\u003ESee \u003Ca href=\"http://blogs.msdn.com/brada/archive/2003/09/30/50396.aspx\" rel=\"nofollow\"\u003Ehttp://blogs.msdn.com/brada/archive/2003/09/30/50396.aspx\u003C/a\u003E\u003Cbr /\u003EYou'll have to effectively store a list of proxy objects for each hash code and then compare the target .NET object of each element in the list to the incoming .NET object for reference equality.\u003Cbr /\u003EThere's also the hard problem of making sure that the global cache does not prevent prevent objects (both Ruby and .NET) from being GC'ed when they are otherwise unreachable.\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cul class='p_action_links'\u003E\n\u003C/ul\u003E\n\n\u003C/article\u003E\n\n\u003C/div\u003E\n\u003Cdiv class='p_comment_form p_logged_in'\u003E\n\u003Ch1\u003ELeave a Comment\u003C/h1\u003E\n\u003Cform action=\"/responses/create\" class=\"new_comment clearfix\" id=\"new_comment\" method=\"post\"\u003E\u003Cdiv style=\"margin:0;padding:0;display:inline\"\u003E\u003Cinput name=\"authenticity_token\" type=\"hidden\" value=\"K5qluXl5HOIU9bWdq9oJYrEuVokj7nLG7aYeXTLdHqg=\" /\u003E\u003C/div\u003E\n\u003Cdiv class='p_not_authorized p_comment_section'\u003E\n\u003Cdiv class='p_additional_fields'\u003E\n\u003Clabel for=\"comment_name\"\u003EName:\u003C/label\u003E\n\u003Cinput id=\"comment_name\" maxlength=\"80\" name=\"comment[name]\" size=\"40\" type=\"text\" /\u003E\n\u003Clabel class=\"p_comment_email\" for=\"comment_comment_email\"\u003ELeave this field blank to comment.\u003C/label\u003E\n\u003Cinput class=\"p_comment_email\" id=\"comment_comment_email\" maxlength=\"80\" name=\"comment[comment_email]\" size=\"40\" type=\"text\" /\u003E\n\u003Clabel for=\"comment_toast\"\u003EEmail:\u003C/label\u003E\n\u003Cinput id=\"comment_toast\" maxlength=\"80\" name=\"comment[toast]\" size=\"40\" type=\"text\" /\u003E\n\u003Clabel for=\"comment_url\"\u003EHomepage:\u003C/label\u003E\n\u003Cinput id=\"comment_url\" maxlength=\"80\" name=\"comment[url]\" size=\"40\" type=\"text\" /\u003E\n\u003C/div\u003E\n\u003Caside class='p_login_options'\u003E\n\u003Cdiv class='p_asterisk'\u003E\u003C/div\u003E\n\u003Ch1\u003EWant to skip this stuff?\u003C/h1\u003E\n\u003Cp\u003ELogin with any of the following:\u003C/p\u003E\n\u003Cdiv class='p_login_buttons'\u003E\n\u003Ca href=\"http://posterous.com/login?flow=newcomment\u0026amp;jumpto=http%3A%2F%2Fiunknown.com%2F2006%2F06%2Frubyclr-identity-woes.html%23comment\" class=\"p_posterous_login\"\u003ERegister or login to Posterous\u003C/a\u003E\n\u003Ca href=\"#\" class=\"p_twitter_login\" data-posterous-jumpto-url=\"http://iunknown.com/2006/06/rubyclr-identity-woes.html#comment\" data-posterous-post-id=\"36933255\" data-posterous-redirect-url=\"http://posterous.com/oauth/init_oauth_and_redirect/?ssod=iunknown.com\u0026amp;oauth_provider_type=\" data-posterous-twitter-login-button=\"true\"\u003E\u003Cimg alt=\"Sign in with Twitter\" src=\"/images/site/sign_in_with_twitter.png?1367517938\" /\u003E\u003C/a\u003E\n\u003C/div\u003E\n\n\u003C/aside\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_section'\u003E\n\u003Clabel for=\"comment_body\"\u003EComment:\u003C/label\u003E\n\u003Cdiv class='p_comment_area'\u003E\n\u003Ctextarea cols=\"40\" id=\"comment_body\" name=\"comment[body]\" onChange=\"if (this.scrollHeight \u0026gt; this.clientHeight \u0026amp;\u0026amp; !window.opera){this.rows += 1;}\" onKeyPress=\"if (this.scrollHeight \u0026gt; this.clientHeight \u0026amp;\u0026amp; !window.opera){this.rows += 1;}\" rows=\"5\"\u003E\u003C/textarea\u003E\n\u003C/div\u003E\n\u003C/div\u003E\n\u003Cdiv class='p_comment_section'\u003E\n\u003Cinput id=\"comment_post_id\" name=\"comment[post_id]\" type=\"hidden\" value=\"36933255\" /\u003E\n\u003Cdiv class='p_submit'\u003E\u003Cbutton button=\"true\" class=\" action_button\"\u003E\u003Cspan class=\"\"\u003EPost this Comment\u003C/span\u003E\u003C/button\u003E\u003C/div\u003E\n\u003C/div\u003E\n\u003C/form\u003E\n\u003C/div\u003E\n\n\u003C/div\u003E\n","responses":[{"name":"Wilco Bauwer","body_html":"Right now what I do in IronRuby to support interfaces is create proxy types on the fly (per interface type). Proxy types derive from a shared base class in which I partially deal with identity (or rather equality). It overloads the relevant operators and implements some relevant interfaces by basically forwarding calls to the underlying Ruby object it represents.\u003Cbr /\u003EThere are some obvious caveats however. Proxy types do not represent the true identity of the underlying Ruby object - it only tries to give you the illusion. When you would actually compare references though (which is what will happen in several scenarios), you will not always get the expected result. Imagine a Ruby object which implements IFoo and IBar and lets say we've got a .NET type with the following methods:\u003Cbr /\u003Evoid X(IFoo f);\u003Cbr /\u003Evoid Y(IBar b);\u003Cbr /\u003EWhen you would pass the Ruby object to X(IFoo f), a proxy type is generated (if it doesn't exist yet) and it is instantiated (if no instance was created yet). In subsequent calls the same proxy type instance will be passed, in which case identity is preserved.\u003Cbr /\u003EHowever, when you would pass the same Ruby object to Y(IBar b) an instance of a different proxy type is passed. Identity crisis is what follows when object references are compared instead of checking equality.","created_at":"2006/06/02 18:18:08 -0700","body":"Right now what I do in IronRuby to support interfaces is create proxy types on the fly (per interface type). Proxy types derive from a shared base class in which I partially deal with identity (or rather equality). It overloads the relevant operators and implements some relevant interfaces by basically forwarding calls to the underlying Ruby object it represents.\nThere are some obvious caveats however. Proxy types do not represent the true identity of the underlying Ruby object - it only tries to give you the illusion. When you would actually compare references though (which is what will happen in several scenarios), you will not always get the expected result. Imagine a Ruby object which implements IFoo and IBar and lets say we've got a .NET type with the following methods:\nvoid X(IFoo f);\nvoid Y(IBar b);\nWhen you would pass the Ruby object to X(IFoo f), a proxy type is generated (if it doesn't exist yet) and it is instantiated (if no instance was created yet). In subsequent calls the same proxy type instance will be passed, in which case identity is preserved.\nHowever, when you would pass the same Ruby object to Y(IBar b) an instance of a different proxy type is passed. Identity crisis is what follows when object references are compared instead of checking equality.\n","post_id":36933255,"id":6478189,"display_name":"Wilco Bauwer","comment_type":"comment","display_url":null,"allowed":true,"display_photo":"/images/profile/missing-user-35.png"},{"name":"Nick Guerrera","body_html":"It's probably a good idea to use System.CompilerServices.RuntimeHelpers.GetHashCode. A non-virtual call to Object.GetHashCode is equivalent, but unverifiable.\u003Cbr /\u003EAs for the interface issue, what about getting rid of the .as operation entirely? It seems out of place to me in a world of duck typing.\u003Cbr /\u003ECan you make the original proxy object surface all interface methods as well? I'm sure this already works for implicit interface implementations. For explicit interface implementations, you could elevate them to normal methods in the absence of ambiguity.\u003Cbr /\u003EDealing with ambiguity in the face of explicit interface implementation is the tough part. One dodge would be to use name mangling for disambiguation, but that would break duck typing.\u003Cbr /\u003EI think a better approach would be to provide a method on the proxy object which allows the user to do the disambiguation. For example, given an object which implements both IEnumerable.GetEnumerator and IFoo.GetEnumerator, you could do the following:\u003Cbr /\u003Eobject.select_interface_method(\"GetEnumerator\", IEnumerable)\u003Cbr /\u003Ex = object.GetEnumerator()\u003Cbr /\u003E-- calls IEnumerable.GetEnumerator()\u003Cbr /\u003Eobject.select_interface_method(\"GetEnumerator\", IFoo)\u003Cbr /\u003Ex = object.GetEnumerator()\u003Cbr /\u003E-- calls IFoo.GetEnumerator()\u003Cbr /\u003EJust a thought.","created_at":"2006/06/02 22:42:49 -0700","body":"It's probably a good idea to use System.CompilerServices.RuntimeHelpers.GetHashCode. A non-virtual call to Object.GetHashCode is equivalent, but unverifiable.\nAs for the interface issue, what about getting rid of the .as operation entirely? It seems out of place to me in a world of duck typing.\nCan you make the original proxy object surface all interface methods as well? I'm sure this already works for implicit interface implementations. For explicit interface implementations, you could elevate them to normal methods in the absence of ambiguity.\nDealing with ambiguity in the face of explicit interface implementation is the tough part. One dodge would be to use name mangling for disambiguation, but that would break duck typing.\nI think a better approach would be to provide a method on the proxy object which allows the user to do the disambiguation. For example, given an object which implements both IEnumerable.GetEnumerator and IFoo.GetEnumerator, you could do the following:\nobject.select_interface_method(\u0026quot;GetEnumerator\u0026quot;, IEnumerable)\nx = object.GetEnumerator()\n-- calls IEnumerable.GetEnumerator()\nobject.select_interface_method(\u0026quot;GetEnumerator\u0026quot;, IFoo)\nx = object.GetEnumerator()\n-- calls IFoo.GetEnumerator()\nJust a thought.\n","post_id":36933255,"id":6478190,"display_name":"Nick Guerrera","comment_type":"comment","display_url":null,"allowed":true,"display_photo":"/images/profile/missing-user-35.png"},{"name":"Nick Guerrera","body_html":"Also, the value returned from GetHashCode (whether overridden or not) is not guaranteed to be unique to the object instance and therefore cannot be used as the key into a hashtable.\u003Cbr /\u003ESee \u003Ca href=\"http://blogs.msdn.com/brada/archive/2003/09/30/50396.aspx\" rel=\"nofollow\"\u003Ehttp://blogs.msdn.com/brada/archive/2003/09/30/50396.aspx\u003C/a\u003E\u003Cbr /\u003EYou'll have to effectively store a list of proxy objects for each hash code and then compare the target .NET object of each element in the list to the incoming .NET object for reference equality.\u003Cbr /\u003EThere's also the hard problem of making sure that the global cache does not prevent prevent objects (both Ruby and .NET) from being GC'ed when they are otherwise unreachable.","created_at":"2006/06/03 16:08:49 -0700","body":"Also, the value returned from GetHashCode (whether overridden or not) is not guaranteed to be unique to the object instance and therefore cannot be used as the key into a hashtable.\nSee http://blogs.msdn.com/brada/archive/2003/09/30/50396.aspx\nYou'll have to effectively store a list of proxy objects for each hash code and then compare the target .NET object of each element in the list to the incoming .NET object for reference equality.\nThere's also the hard problem of making sure that the global cache does not prevent prevent objects (both Ruby and .NET) from being GC'ed when they are otherwise unreachable.\n","post_id":36933255,"id":6478191,"display_name":"Nick Guerrera","comment_type":"comment","display_url":null,"allowed":true,"display_photo":"/images/profile/missing-user-35.png"}]}