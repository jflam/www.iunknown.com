
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" >
<HTML>
  <HEAD>
    <title>Recommended book: Facts and Fallacies of Software Engineering
    </title>
    <meta content="JavaScript" name="vs_defaultClientScript">
    <meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
    <LINK href="global.css" type="text/css" rel="stylesheet">
  </HEAD>
  <body MS_POSITIONING="GridLayout">
    <a href="Default.aspx">
      <img id="Image2" class="Logo" src="images/logo.png" alt="iunknown.com: building better software, faster" border="0" /></a>
    <form name="Form1" method="post" action="BookReview.aspx?asin=0321117425" id="Form1">
<input type="hidden" name="__VIEWSTATE" value="dDwxNzczMTIwMDYzO3Q8O2w8aTwxPjs+O2w8dDw7bDxpPDE+O2k8Mz47aTw1PjtpPDc+O2k8OT47aTwxMT47aTwxMz47aTwxND47aTwxNz47PjtsPHQ8cDxwPGw8SW1hZ2VVcmw7PjtsPGh0dHA6Ly9pbWFnZXMuYW1hem9uLmNvbS9pbWFnZXMvUC8wMzIxMTE3NDI1LjAxLl9TQ01aWlpaWlpaXy5qcGc7Pj47Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPEZhY3RzIGFuZCBGYWxsYWNpZXMgb2YgU29mdHdhcmUgRW5naW5lZXJpbmc7Pj47Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPFJvYmVydCBMLiBHbGFzczs+Pjs+Ozs+O3Q8cDxwPGw8VGV4dDs+O2w8JDM0Ljk5Oz4+Oz47Oz47dDxwPHA8bDxUZXh0Oz47bDwkMjMuMDk7Pj47Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPDUuMDs+Pjs+Ozs+O3Q8cDxwPGw8VGV4dDs+O2w8Njs+Pjs+Ozs+O3Q8QDxodHRwOi8vd3d3LmFtYXpvbi5jb20vZXhlYy9vYmlkb3MvQVNJTi8wMzIxMTE3NDI1L3JlZj1ub3NpbS9pdW5rbm93bmNvbS0yMDs+Ozs+O3Q8cDxwPGw8VmlzaWJsZTs+O2w8bzxmPjs+Pjs+O2w8aTwwPjtpPDE+Oz47bDx0PEA8XGU7Pjs7Pjt0PHA8cDxsPFRleHQ7PjtsPFxlOz4+Oz47Oz47Pj47Pj47Pj47PkSkMF5bLcuIHMUb/2WKM5BB0Qiu" />

      <div class="BookReview"><img id="BookImage" class="BookReviewImage" src="http://images.amazon.com/images/P/0321117425.01._SCMZZZZZZZ_.jpg" alt="" border="0" />
        <span id="BookReviewTitle" class="BookReviewTitle">Facts and Fallacies of Software Engineering</span>
        <div class="ItemDetail">By
          <span id="Authors">Robert L. Glass</span></div>
        <div class="ItemDetail">
          <span class="ItemCaption">List price:</span>
          <span id="ListPrice" class="ListPrice">$34.99</span>
          <span class="ItemCaption">Our price:</span>
          <span id="OurPrice" class="OurPrice">$23.09</span>
        </div>
        <div class="ItemDetail">
          <span class="ItemCaption">Average customer review:</span>
          <span id="AverageReview">5.0</span>
          based on
          <span id="TotalReviews">6</span>
          reviews.
        </div>
        <div class="BuyButton">
          <a href='http://www.amazon.com/exec/obidos/ASIN/0321117425/ref=nosim/iunknowncom-20'>
            <img id="Image1" src="Images/buy_from_amazon.gif" alt="" border="0" /></a>
        </div>
        <table class="ReviewBody">
          <tr>
            <td class="ReviewColumn">
              
              <table id="CustomerReviewsPanel" class="ReviewSection" cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td>
	
                <DIV class="ReviewHeading">Customer reviews:</DIV>
                
                    <div class="CustomerReviewSummary">On Computational Feasibility</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>49</span>
                      /
                      <span>75</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-07-10</span>
                    </div>
                    <span>I recommend this book to any software person who wants to find out why most software projects that fail, fail.<P>But my specific interest revolves around writing software in large engineering (hard engineering) companies, in that very peculiar environment. Specifically, the hard engineering environment in which knowledge of the programming language is considered the most advanced software theory needed to produce a product, and in which Electrical Engineers without any formal education in advanced data structures, algorithms to manipulate them, search strategies, and heuristics are writing most of the code.<P>I am seeing HUGE software projects fall FAR short of their schedulled goals, because those doing the coding have simply used up all their computational cycles (I'm talking about real-time software). In these situations, managers seem to imply<BR> 1. they were blindsided<BR> 2. there are no ways to forsee such computational box canyons<BR> 3. no one could have done better, anyway.<P>On all 3 points, managers are wrong. And the substance on which they are so badly wrong, would make for another 10 fallacies in Glass' book. For example:<P>Fallacy N: Hard engineers produce advanced software algorithms.<BR>The average hard engineer is writing Freshman undergraduate code, and making basic errors in design.<P>Fallacy N+1: Simple code (meaning no Computer Science theory) is much more efficient than highly tailored software algorithms. Actually, it is often orders of magnitude less efficient.<P>Fallacy N+2: Analytical mathematical solutions are the only ones worthy of respect. Actually, with the incredibly complex problems in modern engineering, closed form mathematical solns may never be found. Many such solns are so computationally expensive, that they never could be practical solutions.<P>Fallacy N+3: There are no analytical methods for identifying algorithms with prohibitive computational complexity--you must just write the software and try it out. Actually, there is a whole field of C.S. that does this.<P>Fallacy N+4: Modern Engineering problems are unique. Actually, the tar pits of computational complexity remain pretty stable, and Artificial Intelligence has amply failed in most of them (such as the Frame problem, and Automated Reasoning). Managers are just ignorant of the tar pits.<P>Fallacy N+5: Next year we'll get a new processor which is 60% faster, and our problems will go away. Actually, the mathheads that keep saying this have still not figured out that the disastrous software algorithms have computational growth rates that are exponential, and linear growth in processor speed does not define a solution to this problem.<P>Fallacy N+6: We write modular software. Actually, "modular" to a hard engineer and "modular" to a software engineer are radically different things. I regularly see "modular" software that has no defined interface, and no behavioral contract, so does not meet even basic requirements for reuse. Glass does not address the radically different semantics given the same words, by software and hard engineers. "Algorithm" is another word with very different meanings.<P>Fallacy N+7: Rule-Based software will, of course, solve our problem. Actually, automated reasoning has large undecidable and intractable areas. Engineering companies are just beginning to step in this tar pit, 25 years behind Artificial Intelligence.<P>Fallacy N+8: Knowledge of the syntax of a computer language, is the most valuable asset in software design. Actually, this is a trivial skill, relatively. The ability to represent symbolically complex reality in code structures, and complex manipulations of those structures efficiently, is orders of magnitude more valuable. Knowledge of just language syntax leads to literalistic algorithms, which tend to be brute force.<P>To his credit, Glass did mention...<BR>Fallacy: Real-time code optimizers will fix any slowness in execution. Actually, you may gain 10-18% in speed this way, but these failing projects are orders of magnitude slower then needed. Better get rid of the real-time optimizers, and hire highly educated software designers. <P>I REALLY, REALLY appreciate Glass. But someone with a modern Masters degree in C.S. would realize that there is no reason to be blind-sided by most of these software disasters, and there are proven ways of evaluating these risks of failure while still in the design stage. Most VERY VERY bright hard engineers don't have the basic theory to detect computational risk, and don't even know where they should acquire it, if they wanted to improve their software algorithm design ability.<P>The problem is not just that (as Glass mentions) managers of software projects are out of touch with the technical people who write software. The disconnect is rather worse: most of the people who write software in big engineering companies are hard engineers, with no theoretical background in software algorithm design. There is an unspoken "amateur ethic" which condemns formal design theory. Technical leads of these "programmers" are often as uneducated, and could not identify sound software designs if their career depended on it. (So they are continually promoting Public Relations designs, and being blind-sided by failures.)<P>The situation in software design in America remains "tragic," and anti-intellectual, and the amateur (KISS) ethic continues to produce software projects which are computationally orders of magnitude outside of feasibility. Process does not begin to address this problem (Glass alludes to this). Nor does the strategy to redouble expectations toward the 'amateur coding ethic' and stop being such a nay-sayer. The truth remains that most technical leads in engineering companies, cannot even recognize what a software design is, and have no theoretical tools to analyze computational feasibility.<P>I wish that someone would address this problem in basic "Facts and Fallacies" books.<P>Stephen Wuest, Raytheon, M.S. in C.S. and A.I., 1999.</span>
                  
                    <div class="CustomerReviewSummary">Maybe the most important book you will ever read</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>6</span>
                      /
                      <span>8</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-07-02</span>
                    </div>
                    <span>Once again, Glass has proven that he belongs in the software engineering pantheon along with Tom DeMarco, Gerry Weinberg, and Steve McConnell.<P>This book will open your eyes. If you work in the field, you'll never think about your livelihood the same way again.<P>If you take only one thing away from this book, remember this: don't blindly trust what the advocates of the latest methodology are saying, whether it be OO, XP, RUP, or UML, without some substantive evaluative research backing them up. Glass makes compelling arguments as to why the software industry has fallen easy prey to the hucksters and snake-oil salesmen.</span>
                  
                    <div class="CustomerReviewSummary">Insightful To The New Manager/Team Leader</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>11</span>
                      /
                      <span>11</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-04-04</span>
                    </div>
                    <span>The other reviewers have done a fine job of covering the content of the book. I will comment about its usefulness. In short, this book is truly valuable to the developer who has recently been promoted to team leader. While developers would benefit greatly from this book, the reality is that most developers would rather read books like "Effective C++", "Design Patterns", "Expert One on One Oracle", etc. To the new manager, though, this book is a gem. The book talks about specific management issues as well as the development life cycle and quality. In short, the book focuses exactly on what the team leader does and the team leader's team. In addition to the material presented in the book, the author gives a great number of sources and reference for further reading.</span>
                  
                    <div class="CustomerReviewSummary">Good summary of Software Engineering ideas and trends</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>7</span>
                      /
                      <span>7</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2003-02-28</span>
                    </div>
                    <span>Written in the style of "Effective */More Effective *", this book presents what the author asserts are 55 facts about software engineering.<P>While you will see the obligatory "Adding people to a late project makes it later" section, the book also introduces several 'facts' that I have never really thought much about e.g. "Enhancements represent roughly 60 percent of maintenance costs"<P>The true gems of this book are the 'source' and 'reference' section of each fact. Their purposes are twofold. Firstly, they serve to validate the author's claim for each of these facts. Secondly, they provide readers with good follow-ups.<BR>Amazingly, many if not most of the software classic are somehow mentioned in this book. (Even the cult classic Zen and the Art of Motorcycle Maintenance!)<P>This book manages to capture most of the essence of software engineering literature of today. Certainly, you may not agree with what the author terms as facts. The author does attempt to address these issues under 'Controversy' for each fact.<P>If you read this book, be sure to follow up on your reading with one of the many mentioned articles/books. Otherwise, you could potentially be left with only a surface understanding of the many issues involved.<P>Fact 56: "This reviews is written from the viewpoint of a 4 year old software developer in Singapore"</span>
                  
                    <div class="CustomerReviewSummary">A valuable and easy to read summary of the state of the art</div>
                    <div>
                      <span class="ItemCaption">Rating: </span>
                      <span>5</span>
                      <span class="ItemCaption">Helpful: </span>
                      <span>22</span>
                      /
                      <span>22</span>
                      votes <span class="ItemCaption">Reviewed: </span>
                      <span>2002-12-16</span>
                    </div>
                    <span>I have read a fair number of software engineering books, and this is one of the more enjoyable books that I have read. When I first heard about it, I thought the concept of a sort of summary of the state of the art sounded really interesting. Although I haven't read any of the author's previous books, I have read and enjoyed his columns in IEEE Software and Communications of the ACM, so I had high hopes about this book. And I wasn't disappointed.<P>Facts and Fallacies of Software Engineering is divided into 55 facts and 10 fallacies. Each fact and fallacy is presented in the same way. There is a headline/slogan that summarizes it, usually one or two pages of Discussion giving more details, then a Controversy section describing what (if anything) people disagree about and finally Sources and References.<P>The 55 Facts are divided into the following sections and sub-sections: Management (People, Tools and Techniques, Estimation, Reuse, Complexity), Life Cycle (Requirements, Design, Coding, Error Removal, Testing, Reviews and Inspections, Maintenance), Quality (Quality, Reliability, Efficiency) and Research.<P>The 10 Fallacies are divided into Management, Life Cycle and Education.<P>This way of organizing the material works really well, and makes the book very accessible and easy to read. It also allows you to jump around and read what interests you the most first (which is what I did, although I eventually read all of it).<P>Many of the facts are well known (for example Fact 3 "Adding people to a late project makes it later", Fact 16 "Reuse-in-the-large remains a mostly unsolved problem" and Fact 24 "Requirement errors are the most expensive to fix during production"), but that doesn't matter. It is actually good to be reminded of these facts even if you already know them, and the author does a very good job of summarizing them.<P>Another thing I like about the book is the Sources and Reference parts (although I think they might as well have been combined into just one Reference section). Often there are references to research papers where the original fact was presented. It is nice to know that what is presented as a fact is indeed a fact that has been validated by research, and not just the opinion of the author (although there is certainly room for opinions in a lot of places as well).<P>There are also lots of references to other books on software engineering, and a lot of the classic books (like The Mythical Man-Month, Peopleware and Design Patterns) are referenced. So there is plenty of leads in case you want to find out more about a certain fact.<P>Among the facts I liked the most were Fact 12, Fact 21 and Fact 26. <P>Fact 12: "Since estimates are so faulty, there is little reason to be concerned when software projects do not meet estimated targets. But everyone is concerned anyway". This fact and the related ones simply state that when a project is late, it is very likely because the estimated time to complete it was unrealistic. Very true.<P>Fact 21: "For every 25 percent increase in problem complexity, there is a 100 percent increase in complexity of the software solution." I had never seen this fact before, but it does ring true to me. And as the author writes, it explains a lot of the other facts in the book as well.<P>Fact 26: "Explicit requirements 'explode' as implicit (design) requirements for a solution evolve". In other words, each explicit requirement leads to many more implicit requirements (by a factor of up to 50). This too I had never seen stated, but I definitely recognize this from my own experience.<P>The Fallacies section list ten common misunderstandings in software engineering, and this is where I disagree on a couple of points. Fallacy 7 states "Random test input is a good way to optimize testing". I agree that it can not be the only test approach, but since he also writes "It may or may not survive as a test approach", he is skeptical to it in general. My own experience is that it is an invaluable complement that helps flush out numerous what I call "timing dependent" bugs caused by the nature of asynchronous events.<P>I also don't think all his arguments in Fallacy 8 are valid. I agree that since there is no data demonstrating the truth of "Given enough eyeballs, all bugs are shallow", we should not just accept it as truth. But I think he misses the point when he refers to research showing that inspections don't get much extra benefit beyond 2 to 4 participants. My interpretation is that the "enough eyeballs" are not so much inspecting the software in question as running it and debugging it when there is a problem. And the "all bugs are shallow" should not be interpreted too literally. Of course the bugs may still be difficult, but if many people look at it, the chances of someone solving it fairly quickly increases. <P>Those two examples notwithstanding, I did find myself nodding my head and saying "yes, I agree with that" almost all of the time reading this book.<P>There are many more interesting facts that I have not commented on, and if you are interested in software engineering I highly recommend this book.</span>
                  
              
</td></tr></table>
            </td>
            <td class="ReviewSideBar">
              <div class="ItemCaption">Customers also bought:</div>
              
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=0932633439'>
                      Peopleware : Productive Projects and Teams, 2nd Ed.
                    </a>
                    <div class="SimilarItemRatings">Rating: 4.9 based on 48 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=0932633609'>
                      Waltzing With Bears: Managing Risk on Software Projects
                    </a>
                    <div class="SimilarItemRatings">Rating: 4.6 based on 16 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=0735619670'>
                      Code Complete, Second Edition
                    </a>
                    <div class="SimilarItemRatings">Rating: 5.0 based on 3 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=0321193679'>
                      Professional Software Development: Shorter Schedules, Higher Quality Products, More Successful Projects, Enhanced Careers
                    </a>
                    <div class="SimilarItemRatings">Rating: 4.1 based on 15 reviews</div>
                  </div>
                
                  <div class="SimilarItem">
                    <a href='BookReview.aspx?asin=0767907698'>
                      Slack : Getting Past Burnout, Busywork, and the Myth of Total Efficiency
                    </a>
                    <div class="SimilarItemRatings">Rating: 3.7 based on 28 reviews</div>
                  </div>
                
              <div class="GoogleBookAd">
                <script type="text/javascript"><!--
                google_ad_client = "pub-8264790134546506";
                google_ad_width = 160;
                google_ad_height = 600;
                google_ad_format = "160x600_as";
                google_ad_channel ="4375045039";
                google_color_border = "CCCCCC";
                google_color_bg = "FFFFFF";
                google_color_link = "000000";
                google_color_url = "666666";
                google_color_text = "333333";
                //--></script>
                <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
                </script>
              </div>
            </td>
          </tr>
        </table>
      </div>
    </form>
  </body>
</HTML>
