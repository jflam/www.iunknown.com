<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

<title>iunknown.com: When less is more</title>

<link rel="stylesheet" href="http://www.iunknown.com/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://www.iunknown.com/index.rdf" />

<link rel="start" href="http://www.iunknown.com/" title="Home" />
<link rel="prev" href="http://www.iunknown.com/000152.html" title="Fun time at Win-Dev" />

<link rel="next" href="http://www.iunknown.com/000154.html" title="DevConnections" />


<script type="text/javascript" language="javascript">
<!--

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

var HOST = 'www.iunknown.com';

// Copyright (c) 1996-1997 Athenia Associates.
// http://www.webreference.com/js/
// License is granted if and only if this entire
// copyright notice is included. By Tomer Shiran.

function setCookie (name, value, expires, path, domain, secure) {
    var curCookie = name + "=" + escape(value) + ((expires) ? "; expires=" + expires.toGMTString() : "") + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + ((secure) ? "; secure" : "");
    document.cookie = curCookie;
}

function getCookie (name) {
    var prefix = name + '=';
    var c = document.cookie;
    var nullstring = '';
    var cookieStartIndex = c.indexOf(prefix);
    if (cookieStartIndex == -1)
        return nullstring;
    var cookieEndIndex = c.indexOf(";", cookieStartIndex + prefix.length);
    if (cookieEndIndex == -1)
        cookieEndIndex = c.length;
    return unescape(c.substring(cookieStartIndex + prefix.length, cookieEndIndex));
}

function deleteCookie (name, path, domain) {
    if (getCookie(name))
        document.cookie = name + "=" + ((path) ? "; path=" + path : "") + ((domain) ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
}

function fixDate (date) {
    var base = new Date(0);
    var skew = base.getTime();
    if (skew > 0)
        date.setTime(date.getTime() - skew);
}

function rememberMe (f) {
    var now = new Date();
    fixDate(now);
    now.setTime(now.getTime() + 365 * 24 * 60 * 60 * 1000);
    setCookie('mtcmtauth', f.author.value, now, '', HOST, '');
    setCookie('mtcmtmail', f.email.value, now, '', HOST, '');
    setCookie('mtcmthome', f.url.value, now, '', HOST, '');
}

function forgetMe (f) {
    deleteCookie('mtcmtmail', '', HOST);
    deleteCookie('mtcmthome', '', HOST);
    deleteCookie('mtcmtauth', '', HOST);
    f.email.value = '';
    f.author.value = '';
    f.url.value = '';
}

//-->
</script>





</head>

<body>

<div id="banner">
<h1><a href="http://www.iunknown.com/" accesskey="1"><img src="/mt-static/images/iunknown.png" width="350" height="60" border="0"></a></h1>
<span class="description">Home of the Practical Eye for the .NET Guy</span>
</div>

<div id="container">

<div class="blog">

<div id="menu">
<a href="http://www.iunknown.com/000152.html">&laquo; Fun time at Win-Dev</a> |

<a href="http://www.iunknown.com/">Main</a>
| <a href="http://www.iunknown.com/000154.html">DevConnections &raquo;</a>

</div>

</div>


<div class="blog">

<h2 class="date">October 31, 2002</h2>

<div class="blogbody">

<h3 class="title">When less is more</h3>

<p><P>My flight to Orlando, FL earlier this week took me through NYC and inspired an epiphany; this entry describes that epiphany.</P><br />
<P>Over the past week or so, I've been spending a lot of time thinking<EM> </EM>about code generation. <A href="http://www.frogware.com">Michael Lenaghan</A>, who has been one of my most important mentors since we met in 1995, recently got me thinking about code generation. <A href="http://www.sellsbrothers.com">Chris Sells</A>, who actually <EM>created </EM>a <A href="http://www.develop.com/genx">code generation product</A>, was unable to convince me of the importance of code generation. Why did one of my friends succeed where the other failed?</P><br />
<P>It has everything to do with how they motivated the need for code generation. Chris' motivation was that code generation was capable of capturing knowledge for the purpose of <EM>reusing</EM> it in different contexts. Michael's motivation was that code generation was capable of building abstractions that were not possible using traditional techniques.&nbsp;The problem with Chris' motivation was that this wasn't a problem that I encountered in my day-to-day work. I <EM>rarely</EM> had&nbsp;code that I needed to reuse in different contexts. However,&nbsp;I <EM>often&nbsp;</EM>run into the scenario that Michael described: there are simply limits to my ability to understand problems using traditional programming techniques. I needed to use a more powerful tool.</P><br />
<P>These two motivational approaches remind me of how OOP is often motivated. Some folks motivate OOP as a code reuse technology, others motivate OOP as a mechanism for building abstractions. I think that today, most OOP practitioners would agree that it is really about building abstractions that let you visualize the problem more clearly. Not many people would claim today that they have seen significant code reuse opportunities arising out of their use of OOP.</P><br />
<P>Today, I strongly believe that code generation is <EM>not</EM> a code reuse technology. Instead, it is a very powerful tool that lets you think about software from a higher level of abstraction. But how does it let you think "at a higher level of abstraction"? This is the contribution that airplanes bring to the story.</P><br />
<P>We had fairly clear skies over NYC, so the descent into the NYC region allowed me to think about the parallels that lie between altitude and abstraction. From a fairly high altitude, I was able to see the high-level structures of the city. I could see the Hudson river, I could make out Long Island in the distance, I could see the outline of Manhattan, but I could see little else.</P><br />
<P>As we descended, I noticed that there was a change in the amount of order that I saw. Structures that were previously very ordered when viewed at a higher altitude became less ordered upon closer inspection. Also, I noticed that order that previously wasn't observable became apparent, and then disappeared into apparent randomness as we drew closer. </P><br />
<P>An important question is: why did order "appear" and then "disappear"? This observation stems from a well-studied concept in psychology: the 7 +/- 2 rule. Simply put, it is the amount of information that can be stored in your short term memory. The disappearance of "order" corresponds to hitting the limit imposed by 7 +/- 2; the elements in the scene become too complex to process using your short term memory.</P><br />
<P>The same principles are at work when you look at software. When methods get too long, or attempt to do too many things, you lose the ability to understand their operation. When classes get too complex, again you lose the ability to comprehend their implementation. Patterns, OOP,&nbsp;and structured programming are all techniques that we use to create the abstractions that we use in our programs.</P><br />
<P>But is it enough? As most of you reading this have experienced, there are limits to what you can do with Patterns, OOP, and structured programming. You find that there are features that cut across your well-designed class hierarchies and object graphs. These are the warts in your program that spring to life innocently enough, but then spread as your program becomes increasingly more complex. It is these warts that make it hard for you to <EM>comprehend</EM> your software. It is these warts that make it hard for you to <EM>extend </EM>your software's functionality.</P><br />
<P>So is code generation the answer to all problems? Of course not. However, it is a tool that works exceedingly well in certain scenarios. One scenario that I have a lot of experience in is building metadata parsers. This is a specific&nbsp;instance of the more general class of problems that arise when building parsers and translators.</P><br />
<P>How does my code generator work? There are two different parts: the "mini language" and the code generator. The mini language defines the solution to the problem (in my case a parser that parses metadata tables). The code generator is the glue that converts my mini language into C# source code.</P><br />
<P>I chose not to build my own code generator (which, as a long-time C++ programmer, required supression of my natural instincts). Instead, I used an obscure, open-source code generator called GSLgen. GSLgen is not a particularly great code generator, but it had one important characteristic: <EM>it was good enough</EM>. GSLgen is a surprisingly powerful blend of a primitive scripting language with a rudimentary XML parser. You define your mini language using XML (to avoid having to write a parser) and you implement your code generator using their mini-scripting language / XML parser.</P><br />
<P>During my code generation experiments, I was able to condense approximately 8000 lines of hand-written C# code into about 600 lines of a custom XML language that was in turn fed to about 500 lines of scripting code that generated a functionally equivalent parser. While I was writing this software, I was continuously amazed by the subtle semantics that kept popping up while I was defining my custom XML language. This led to an iterative development process where I would see a new abstraction, modify my language, tweak my code generator, and then test the results of the change using <EM>traditional tools </EM>(in my case Visual Studio .NET).</P><br />
<P>Why did I do all of this? Because it turned me into a vastly better developer. Code generation let me see the problem space from a <EM>much </EM>higher level of abstraction than I had seen before. Not only was my code-generated metadata parser functionally equivalent to my original hand-written parser, it had fewer bugs, it was faster, and most important of all, I developed it quicker than my original parser.</P><br />
<P>Is code generation without its own warts? Of course not. Writing code generators and defining mini-languages is <EM>hard</EM>. It requires someone who has the ability to think very abstractly about problems, and who has the patience to see it through. Particularly at the beginning when one is not sure whether the long-term results are worth all of the short-term pain.</P><br />
<P>Personally, I'm very excited about the prospects of using code generation in the software that I create. It is a new and extremely powerful tool in my toolbox. Hopefully this article will inspire you to think about adding code generation to your toolbox. But don't just believe me, <A href="http://www.paulgraham.com/lib/paulgraham/pgtalk-rev2.pdf">read this article next</A>.</P></p>

<a name="more"></a>


<span class="posted">Posted by John at October 31, 2002 12:02 PM

<br /></span>

</div>

<div class="comments-head"><a name="mailthisentry"></a>Mail this entry</div>

<form method="post" action="http://www.iunknown.com/cgi-bin/mt-send-entry.cgi">
<input type="hidden" name="entry_id" value="153" />
<input type="hidden" name="_redirect" value="http://www.iunknown.com/000153.html" />
Email this entry to:<br />
<input name="to" size="20" /><br /><br />
Your email address:<br />
<input name="from" size="20" /><br /><br />
Message (optional):<br />
<textarea name="message" rows="5" cols="20" wrap="virtual"></textarea><br /><br />
<input type="submit" value="Send" />
</form>


<div class="comments-head"><a name="comments"></a>Comments</div>

<div class="comments-body">
<p>This is very interesting idea (almost obvious, after you think about it)... but after looking at GSLgen, it seems that I could do all the same things with XSL... I could do my model in XML and use XSL to transform it into any type of file I want.  I see a few tiny things that GSLgen adds that XSL doesn't (out of the box), but it would be rather simple to build in the necessary functionality... plus, XSL seems to have much more power than GSLgen.</p>

<p>Thoughts?</p>
<span class="comments-post">Posted by: <a href="mailto&#58;degolove2&#64;yahoo&#46;com">Nick Franceschina</a> at January 26, 2004 11:17 PM</span>
</div>




</div>
</div>
</body>
</html>
